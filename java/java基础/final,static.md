# final,static
## 1
```
下列关于一个类的静态成员的描述中，不正确的是
正确答案: D   你的答案: D (正确)
A,该类的对象共享其静态成员变量的值
B,静态成员变量可被该类的所有方法访问
C,该类的静态方法能访问该类的静态成员变量
D,该类的静态数据成员变量的值不可修改
```
```
该类的对象共享其静态成员变量的值
静态成员变量可被该类的所有方法访问
该类的静态方法只能访问该类的静态成员变量
该类的静态数据成员变量的值可修改
```
## 2
定义在类中的变量是类的成员变量，可以不进行初始化，Java会自动进行初始化，如果是引用类型默认初始化为null,如果是基本类型例如int则会默认初始化为0
局部变量是定义在方法中的变量，必须要进行初始化，否则不同通过编译
被static关键字修饰的变量是静态的，静态变量随着类的加载而加载，所以也被称为类变量
被final修饰发变量是常量

## final

final、finally和finalize的区别中，下述说法正确的有？
正确答案: A B 
final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
finally是异常处理语句结构的一部分，表示总是执行。
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。
引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。
![](_v_images/20190518174618086_744902043.png =1060x)
final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）
**finalize方法，这个选项错就错在，这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。**

## 3
```
byte b1=1,b2=2,b3,b6,b8;
final byte b4=4,b5=6,b7;
b3=(b1+b2);  /*语句1*/ (错)
b6=b4+b5;    /*语句2*/
b8=(b1+b4);  /*语句3*/ (错) 
b7=(b2+b5);  /*语句4*/ (错)
System.out.println(b3+b6);
下列代码片段中，存在编译错误的语句是()
正确答案: B C D   你的答案: A B C D (错误)
语句2
语句1
语句3
语句4
```
------------知识点------------
Java表达式转型规则由低到高转换：
1、所有的byte,short,char型的值将被提升为int型；
2、如果有一个操作数是long型，计算结果是long型；
3、如果有一个操作数是float型，计算结果是float型；
4、如果有一个操作数是double型，计算结果是double型；
5、**被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。**
--------------解析--------------
语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；
语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型；
语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);
语句4错误：**b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。**

## 4
```
public class Test
{
    public int x;
    public static void main(String []args)
    {
        System. out. println("Value is" + x);
    }
}
```
错误,静态方法中不能够调用实例属性,x默认是0