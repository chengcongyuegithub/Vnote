# 其他
## ~的应用
```
int i = 5;
int j = 10;
System.out.println(i + ~j);
```

```
10原码：0000000000000000,0000000000001010；
~10： 1111111111111111,1111111111110101  变为负数，计算机用补码存储
~10反码：10000000000000000,0000000000001010
~10补码：10000000000000000,0000000000001011，等于 -11
```
## a+(-b)
```
变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000； 变量b是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？（）
```
```
0Xf000000000000000 = 0x1111............(全0)
0x7FFFFFFFFFFFFFFF = 0x0111............(全1)
```
我们先知道如果是8为数,我们最多可以表示的值是-128------127,也就是最大的值就是01111111,所以只要是说有符号了,那么最开始的位就是符号位,然后我们看这一道题,第一个数是负数,第二个数是正数,a-b=a的补码-b的补码.我们先来看a的补码
```
我们注意,这道题最开始给的全都是补码形式,因为是在计算机内部存储的
```
a的补码解决完了,然后就是b的补码,它本身就是补码,然后我们求(-b)的补码
```
本身是补码,将它转化成自己的相反数,就是将整个取反+1
100000......1
```
然后运算
```
1111000000000000000000000000000000000000000000000000000000000000+
1000000000000000000000000000000000000000000000000000000000000001=

10111000000000000000000000000000000000000000000000000000000000001(超过的位数直接舍去)
0111000000000000000000000000000000000000000000000000000000000001
```
充分理解这一道题
```
最开始的值就是补码
运算过程中补码的取反就是连同符号为一起取反加1
最后超过的位数直接舍去
```
## short转化成byte
```
经过强制类型转换以后，变量a, b的值分别为（ ）short a = 128; byte b = (byte) a;
A,128  127
B,128  -128
C,128  128
D,编译错误
```
都是一直有符号位的,所以变成二进制之后的第一位就是符号位,
```
short类型  0........ 10000000 这个时候1还不是符号位,我们截断之后剩下8位10000000,其中1就是符号位了,并且这个10000000是以补码的形式存在于电脑中的,所以这个10000000是个补码,我们看的是原码就是(符号位加上绝对值)
原码取反加1=补码
所以补码-1就是反码,在取反就是原码
01111111 -------> 10000000 所以是128,原码是不算符号位的,这个时候我们加上负号 -128
```
