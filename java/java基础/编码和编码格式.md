# 编码和编码格式
## Unicode

Unicode编码定义了这个世界上几乎所有字符（就是你眼睛看到的长那个样子的符号）的数字表示
也就是说Unicode为每个字符发了一张身份证，这张身份证上有一串唯一的数字ID确定了这个字符
在这个纷乱世界上存在的唯一性。
**Unicode给这串数字ID起了个名字叫［码点］（Code Point）**
```
Unicode相当于是一个映射关系,将不同的字符转化成一连串的数字ID,然后这个ID就是码点
```
![](_v_images/20190518154824958_1617998143.png =660x)
而很多人说的编码其实是想表达［Unicode转换格式］（即UTF，Unicode Transformation Formats）
有没有觉得眼前一亮豁然开朗？没错 这就是我们看到的UTF-8/UTF-16/UTF-32的前缀来源
这个［Unicode转换格式］的存在是为了解决［码点］在计算机中的二进制表现形式而设计的
毕竟我们的机内表示涉及存储位宽，兼容古老编码格式，码点是数值过大的罕见字符等问题
［码点］经过映射后得到的二进制串的转换格式单位称之为［码元］（Code Unit）。
```
现在通过Unicode我们将所有的字符转化成了码点,然后我们要将码点可以在计算机内部存储,
那么我们要将它全部转化成二进制的形式,然后这个被称作是码元.
```
**也就是说如果有一种UTF的码点二进制表示有n字节，其码元为8位（1个byte），那么其拥有码元n个。**每种UTF的码元都不同，其宽度被作为区分写在了UTF的后缀——这就是UTF-8/UTF-16/UTF-32的由来。UTF-8的码元是8位的，UTF-16的码元是16位的。大部分的编程语言采用16位的码元作为机内表示。这就是我们在各种语言中调用获取一个字符串中character的数量时会出现这么多混乱的原因。事实上我们调用这些方法时取得的不是字符个数，而是码元个数！一旦我们的字符串中包含了位于基本平面之外的码点，那么就会需要更多的码元来表示，这个时候就会出现测试时常见的困惑——为何return的字符数比实际字符数要多？所以实际写代码时要特别注意这个问题。

## 题目1
编码： 编码就是一个编号(数字)到字符的一种映射关系，就仅仅是一种一对一的映射而已，可以理解成一个很大的对应表格
java默认的字符集是Unicode（占两个字节byte，一个字节=8比特位bit，所以每个Unicode占用16比特位）
编码格式：编码格式 是用来序列化或存储编码中提到的那个“编号(数字)”的一种“格式”，包括gbk和utf-8
    gbk： 是指中国的中文字符，其它它包含了简体中文与繁体中文字符
    UTF-8： 它是一种全国家通过的一种编码
在java中一个unicode占2个字节（byte）。
一个字节等于8比特位（bit）。
所以每个Unicode码占用16个比特位。

java 的字符类型采用的是 Unicode 编码方案，每个 Unicode 码占用（16）个比特位。
## 题目2
java 语言使用的字符码集是Unicode