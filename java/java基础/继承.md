# 继承
## 知识点1
**在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。**
```
所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。
```
```
就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。
```
```
package com.ccy.test13;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Method;

class Parent{
    Parent() {
        System.out.println("调用父类构造方法!");
    }
    private static void staticParent() {
        System.out.println("调用父类静态方法");
    }
    private final  void finalParent() {
        System.out.println("调用父类final方法");
    }
    private void printParent(){
        System.out.println("调用父类私有方法");
    }
}
class Child extends Parent {
    public void printChild(){
        System.out.println("调用子类公有方法");
    }
}
public class Test02 {
    public static void main(String[] args) throws Exception {
        //获取子类
        Class clazz = Class.forName("com.ccy.test13.Child");
        //得到父类
        Class superClass = clazz.getSuperclass();
        //得到父类非继承的所以方法
        Method[] methods = superClass.getDeclaredMethods();
        //设置私有方法可以被访问
        AccessibleObject.setAccessible(methods,true);
        for (Method m:methods) {
            System.out.println();
            System.out.println("子类调用方法"+m.getName()+"()的调用结果:" );
            m.invoke(new Child());
        }

    }
}
```
## 知识点2
```
1、Java中一个类不能继承多个具体class。  

2、一个类只可继承自一个具体 class，但可实现多个接口。  
   interface不涉及到实现细节，不与任何存储空间有关连。  
   可以实现合并多个 interface ，达到可向上转型为多种基类的目的。  
   新类可继承自一个具象class，其余继承都得是interfaces。  

3、outer class不可继承自多个具体 class，可在其内部设多个inner class，每个inner class都能各自继承某一实现类。  
   inner class不受限于outer class 是否已经继承自某一实现类。  

4、inner class可以说是多重继承问题的完整解决方案。  
   inner class 可 “继承自多个具象或抽象类”。  
   一个类不能继承自多个一般类。但我们可以让其内部的多个inner class各自继承某一实现类达到类似的目的。
```

非抽象类继承抽象类，必须将抽象类中的方法**重写**，**否则需将方法再次申明为抽象**。所以这个方法还可再次声明为抽象，而不用重写。而用**重载**也错了，**重载**是在同一个类中，重写、覆盖才是在父子类中。
抽象类可以没有抽象方法，接口是完全的抽象，只能出现抽象方法。
抽象类无法实例化，无法创建对象。现实生活中也有抽象类的类子，比如说人类是一个抽象类，无法创建一个叫人类的对象，人继承人类来创建对象。况且抽象类中的抽象方法只有声明，没有主体，如果实例化了，又如何去实现调用呢？
因为类是单继承的，类继承了一个抽象类以后，就不能再继承其他类了
## 知识点3
```
abstract关键字可以修饰类和方法
final类的方法都不能是abstract，因为final类不能有子类
abstract类不能实例化
abstract类的子类必须实现其超类的所有abstract方法(X)可以实现部分,然后子类继续声明为抽象方法
```

## 知识点4
```
方法重写的前提： 必须要存在继承的关系。

方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。

什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。

方法重写要注意的事项：
    1.方法重写时， 方法名与形参列表必须一致。
    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 (***)
    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。(***)
    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。(***)
            Exception(最坏)
            RuntimeException(小坏)

方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。

方法重载的要求
    1. 函数名要一致。
    2. 形参列表不一致（形参的个数或形参 的类型不一致）
    3. 与返回值类型无关。(***)
```