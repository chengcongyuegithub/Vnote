# (六)
## part1
- 加载: 把二进制形式的java类型读入java虚拟机
- 验证:  
- 准备: 为类变量分配内存,设置默认值.还没有到初始化之前,类的变量都没有进行实际的初始化
- 解析: 常量池中寻找类,接口,字段和方法的符号引用,符号引用------>直接引用
- 初始化:赋值正确的初始值
- 类实例化:
  为新的对象分配内存,为实例对象赋默认值,为实例变量赋值正确的初始值
  `java编译器为它编译的每一个类都至少生成一个实例初始化方法,<init>`
- 垃圾回收和对象终结
## part2
### 2.1
类的加载的最终产品class
- java虚拟机自带的加载器
boostrap(根类加载器)
Extension(拓展加载器)
System(应用加载器)
- 用户自己定义的 java.lang.ClassLoader的子类
### 2.2
`类加载器并不需要等到某个类被"首次主动使用"时再加载它`
```
jvm规范允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载的过程中遇到了.class文件缺失或者存在错误,类加载器必须在程序首次主动使用时才会报错
```
如果这个类一直没有被主动使用,就一直不会报错
## part3
类的验证的内容
## part4
### 4.1
类的初始化,我们强化一下类的初始化
```
class Singleton
{
    public static int p1;
    private static Singleton singleton=new Singleton();
    static
    {
        p2=3;
    }
    public static int p2=0;
    private Singleton()
    {
        p1++;
        p2++;
    }
    public static Singleton getSingleton() {
         return singleton;
    }
}
```
类的初始化,从上到下,p2被复制了3,后来又赋值了0,所以最后的结果是0
### 4.2
类的初始化步骤
- 假如这个类没有被加载和连接,那就先进行初始化和连接
- 假如类存在直接的父类,并且这个类还没有初始化 ,那就先初始化父类
- 假如类中有初始化语句,那就依次执行这些初始化语句
### 4.3
类的初始化时机.......主动使用
- 创建类的实例 new一个对象
- 访问某个类或者接口的静态变量,或者对静态变量赋值
- 调用类的静态方法2和3都是对静态的操作,getstatic putstatic invokestatic
- 反射 Class.forName("类名")
- 初始化一个类的子类 初始化子类的时候,父类也会初始化,依次类推
- 启动类(@Test,Main方法)
- 动态语句的支持
`当java虚拟机初始化一个类的时候,要求它的所有父类都已经初始化了,但是这条规则不适用于接口`
- 在初始化一个类的时候,并不会先初始化它所实现的接口
- 在初始化一个接口的时候,并不会先初始化它的父接口
`一个父接口并不会因为它的子接口或者实现类的初始化二初始化,只有当程序首次使用特定接口的静态变量时,才会导致初始化`

`只用当程序访问的静态变量或者静态方法确实在当前类或者当前接口中定义时,才可以任务是对类的或者接口的主动使用`

### 4.4
调用ClassLoader类的loadClassLoader方法加载一个类,并不是对类的主动使用,不会导致类的初始化

## part5
类加载器用来把类加载到java虚拟机中,从jdk1.2版本开始,类加载过程采用双亲委派机制,这种机制能够更好的保证java平台的安全,在这个机制下,除了根类加载器,其他的类加载器都一个一个父加载器.
当java程序请求加载器loader1加载Sample类时,loader1首先委托自己的父加载器区加载sample类.如果父加载器可以加载,则由父加载器完成加载任务


