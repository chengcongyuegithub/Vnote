# 最长递增子串(二)
## 二分查找
二分查找的思路还是很简单的,但是二分查找的细节,还是十分值得研究的,要将二分查找的细节搞明白,并且合理的应用到算法中
### 注意的点
* 循环中while(l<=r),**一定是小于等于**,否则会有问题
* if()添加=的位置和最后输出的相反,我们举两个例子

```
   if(arr[mid]>=num)
   {
       r=mid-1;
   }else
   {
       l=mid+1;
   }
   .....
   最后的结果是arr[l];
```
```
   if(arr[mid]>num)
   {
       r=mid-1;
   }else
   {
       l=mid+1
   }
   ......
   最后的结果是arr[r]
```
* 我们在arr[m]==num的时候,l和r可能相等,也可能是3和5的这种情况,中间夹的就是答案.
###  二分查找的应用
我们可以用二分查找找存在的值,也可以有其他的作用.对于这一道题,我们可以通过二分查找,找到最左边第一个大于或者num的值
![](_v_images/20190521002504758_1371163574.png =660x)
就类似于这样.我们使用二分查找
```
while(l<=r)
{
     int mid=(l+r)/2;   
     if(arr[m]>num)
     {
         r=mid-1; 
     }else
     {
         l=mid+1; 
     }
}
```
这样我们在跳出循环时,r肯定是小于num的,然后l肯定是大于num的.

## 分析
我们新加了一个数组ends,表示的就是有效区,我们要在有效区中进行查找,添加,替换,其中查找的时候就使用二分查找,这样的时间复杂度就是O(logN).
```
for(int i=0;i<arr.length;i++)
{
   //首先确定左边和右边
   //然后通过折半查找,找到有效区数组中的比当前arr[i]大的第一个值
   现在我们有了l和r
   while(l<=r)
   {
      int m=(l+r)/2;
      if(ends[m]>arr[i])//arr[i]就是当前要被比的那个值
      {
          r=m-1;
      }else
      {
          l=m+1;
      }
   }
   这样的话跳出的时候l指向的就是第一个比arr[i]大的值,也就是l
}
这个时候end[l]表示的就是比arr[i]大的第一个值
```
这个时候有两部,第一步我们看看right要不要向右边扩
right=Math.max(right,l);
扩完了之后arr[i]要进入到end中,它肯定放置在end[l]的位置
dp[i]=l+1;
我们看一下书中的做法,只截取其中的一部分
![](_v_images/20190521192423383_1678626046.png =660x)
**ends数组并不能生成最后的子串,其作用就是找到第一个比arr[i]大的值,其位置就是l,然后dp[i]=l+1**(下标从0开始)
**然后就是维护ends数组**

**最后二分查找需要的一定是l,不可能是r**
我们来解释一下这个的必然性
因为二分查找有两种情况,就是带等于和不带等于
```
while(l<=r)
{
    int m=(l+r)/2;
    if(ends[m]>arr[i])
    {
        r=m-1; 
    }else
    {
        l=m+1;
    }
}
```
这个里面,arr[i]可能有可能没有,有的话r指向的就是arr[i],l指向的是arr[i]的下一个
如果没有的话,r指向的就是比arr[i]小的值,l指向的是比arr[i]大的值,所以这种情况选择l
```
while(l<=r)
{
    int m=(l+r)/2;
    if(ends[m]>=arr[i])
    {
        r=m-1; 
    }else
    {
        l=m+1;
    }
}
```
如果有的话,r指向的是前一个,l指向的是arr[i]
如果没有话,l指向的就是比arr[i]大的第一个值(l<=r)的条件,最后跳出一定是l比r要大