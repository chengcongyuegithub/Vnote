# 换钱的最少货币数(一)
## 题目
![](_v_images/20190515202352071_256130166.png =660x)
看下面的几个例子
![](_v_images/20190515202447272_1058443459.png =660x)
## 分析
### dp[i][j]含义的确定
对于动态规划,我们首先要确定dp[i][j]的含义,像两个字符串匹配,那就是i和j就分别代表这两个字符串的下标
这里i和j就表示使用arr[0....i]中的钱,能够组成j的钱的最小张数,那么我们的结果就是dp[i][j]
```
i表示的是现有情况
j表示的是现有情况造成的结果,这个根据实际情况进行变更
```
然后就是先分析边界,然后在分析中间的位置
### 边界位置的分析
dp[0][0]=0
先分析dp[0][j],这个时候我们使用arr[0]中的钱,比如是5,然后能够组成的j有5,10,15,20,所以
```
dp[0][5]=1,dp[0][10]=2,dp[0][15]=3,dp[0][20]=4其他的位置都是0
```
第一列分析完毕,然后分析第一行
dp[i][0]表示组成的钱数为0,这个时候第一行的所有值都是0
### 中间位置的分析
我们现在要取得dp[i][j]的值,我们看一下我们可以修改哪些帮助
```
如果我们不使用arr[i]的值,那么有可能的情况如下
dp[i-1][j],
dp[i-1][j-arr[i]]
dp[i-1][j-arr[i]*2]
....
```
同时
```
dp[i][j]=dp[i-1][j],
dp[i][j]=dp[i-1][j-arr[i]]+1;
dp[i][j]=dp[i-1][j-arr[i]*2]+2;
....
```
我们把这个公式一般化
dp[i][j]=dp[i-k][j-arr[i]*k]+k;
然后我们要在其中找到一个最小的.先分析到这儿
我们开始寻求当前这一行的帮助.这里理解起来比较复杂,我们进行一个推导
```
dp[i][j]=Math.min(dp[i-1][j-arr[i]]+1,dp[i-1][j-arr[i]*2]+2,dp[i-1][j-arr[i]*3]+3......)
----->一般表达式
dp[i][j]=MIN(dp[i-1][j-arr[i]*k]+k)(k>=0)
        我们获得到了它最上面的dp情况,把他分离
        ----->>MIN(dp[i-1][j],dp[i-1][j-arr[i]*k]+k)(k>0)
        我们为了能够凑到当前这一行(一会通过图详细解释)
        ----->>MIN(dp[i-1][j],dp[i-1][j-arr[i]*y-arr[i]]+y+1)(k>1)         
```
然后我们知道
```
dp[i][i-arr[i]]=MIN(dp[i-1][j-arr[i]-arr[i]*y]+y)
```
所以得到结论dp[i][j]=MIN(dp[i-1][j],dp[i][i-arr[i]]+1),我们可以通过上面和左边推出当前的位置,我们或一张图
![](_v_images/20190515210427620_2011901293.png =660x)
## 实际例子分析
我们现在知道为什么中间位置dp[i][j]的得出如下
```
dp[i][j]=Math.min(dp[i-1][j],dp[i][j-arr[i]]+1);
```
### 边界
我们通过实际的例子分析一下,我们假设数组[3,2,1],aim为6,我们先分析边界
#### 边界1
```
1,dp[0][0]就是只使用arr[0],也就是3这个货币,组成0这个数字,最少能够花多少张纸币,肯定是0张,一张都不用花
2,dp[i][0]可以使用所有的纸币,组成和为0的和的最少的纸币,肯定是0
1,2可以合成为1中情况
```
#### 边界2
```
dp[0][j]的意思就是,我们只通过arr[0]的纸币,可以组成和为j的最少张数,比如说我们arr[0]为5,那么组成1,2,3,4的都没有,组成5的有一张,同理组成6,7,8,9的没有,组成10的有两张,那么我们看我们这一道题
```
```
0 没有 没有 1 没有 没有 2  
```
上面就是全部的第一行的情况
现在我们就要讨论一个问题**无法组成钱数的位置,用什么数字来表示**,按理来说使用-1就可以表示,不合法,但是我们根据这一道题的递推式子
```
dp[i][j]=Math.min(dp[i-1][j],dp[i][j-arr[i]]+1);
```
我们要从上面或者是左边去比较小的,如果是-1的话,这个比所有合法的值都小,所以我们要去一个比所有值都大的.Integer.max_value
```
0 max max 1 max max 2
```
### 中间位置的分析
我们把现在的二维数组展示一下
```
0 max max 1 max max 2
0  ?   ?  ?  ?   ?  ?  
0  ?   ?  ?  ?   ?  ?
```
我们先来看arr[1][1],使用前两个数字,组成1的总张数,肯定为max,arr[1][2],我们使用前两个数字,组成2,那么只使用第二个就可以了,这个位置为1
然后再来看arr[1][3],组成三的话,我们只能够选择3了,然后arr[1][4],这个时候我们要使用两个2,arr[1][5],这个时候我们要使用1个2和一个3,然后就是arr[1][6],我们可以选择两个3或者是3个2,这个时候,我们选择张数比较少的.
```
0 max max 1 max max 2
0 max  1  1  2   2  2  
```
然后我们来分析递推式的实际意义
为什么可以在dp[i-1][j],dp[i][j-arr[i]]+1这两个中选
```
首先是dp[i-1][j]这个意思就是说,我们不使用arr[i]的货币,直接就是上面的那种情况
dp[i][j-arr[i]]+1的意思是说,我们在保证j-arr[i]使用货币最少的情况下,我们在使用一张当前的货币
```
上面的两个种情况都是保证最少的情况下,然后进行改进,得到的结果肯定也是最小的.
## 代码实现
```
public static int minCoins1(int[] arr,int aim)
    {
        if(arr==null||arr.length==0||aim<0)
        {
            return -1;
        }
        int max=Integer.MAX_VALUE;
        int[][] dp=new int[arr.length][aim+1];
        //bianjie
        dp[0][0]=0;
        for(int j=1;j<=aim;j++)
        {
            if(j>=arr[0]&&j%arr[0]==0)
            {
                dp[0][j]=j/arr[0];
            }else
            {
                dp[0][j]=max;
            }
        }
        //middle
        for(int i=1;i<dp.length;i++)
        {
            for(int j=1;j<=aim;j++)
            {
                int cur=max;
                if(j-arr[i]>=0&&dp[i][j-arr[i]]!=max)
                {
                     cur=dp[i][j-arr[i]]+1;
                }
                dp[i][j]=Math.min(cur,dp[i-1][j]);
            }
        }


        return dp[arr.length-1][aim]!=max?dp[arr.length-1][aim]:-1;
    }
```





