# 5随机到7随机以及拓展
## 题目1
![](_v_images/20190529200926501_814999304.png =660x)
我们倒着分析,我们要求1---7,所以要求0-----6,最后统一加1就可以了.
然后就是要求概率的0....6,7个数,我们可以通过取7的余数来得到等概率的0.....6
然后我们看看借助1----5或者是0------4看看能拼凑出哪些等概率出现的值结果发现0......24这些值是可以等概率出现的
```
(rand1To5())*5+(rand1To5-1)
```
但是0-----24等于7取余数不是等概率的,我们进行压缩,压缩成0-----20
```
do{
    num=(rand1To5())*5+(rand1To5-1)
}while(num>20)
return num%7+1;
```
## 题目2
![](_v_images/20190529203130686_1719166066.png =660x)
首先我们要能够等概率的得到0和1
我们看到题目
```
得到0的概率为p,得到1的概率为1-p,那么我们得到01和10的概率为p*(1-p),这样的话就是等概率了
```
当两次rand01p不相等的时候,返回值,这个时候得到的0和1的概率就是相等的了
```
do{
   num=rand01p()
}while(num==rand01p())
```
![](_v_images/20190529204526308_1471776903.png =660x)
我们可以知道
```
我们等概率的获取(0....x),数量为(x+1),我们就可以等概率的得到
0......x(x+1)的数,然后在这个基础上压缩即可
```
## 题目3
我们现在知道1------m的概率,我们通过上面的概率得到1--------n的概率
### 求进制问题
首先先来解决一个问题,就是将value转化为某个进制表示的数字,比如是2进制
```
我们以13为例子,我们13%2=1,13/2=6
                 6%2=0  6/2=3
                 3%2=1  3/2=1
                 1%2=1  1/2=0      
```
所以二进制为1101,我们跳出,是在value值为0的时候
```
public int[] f(int value,int m)
{
   int[] res=new int[32];
   int index=res.length-1;
   while(value!=0)
   {
       res[index--]=value%m;
       value=value/m; 
   }
   return res; 
}
```
上面是将10进制的数字变成M进制的数,然后我们来想想怎么将其他进制的数字变成10进制
```
对于刚才的1101,,,,,
```
我们从左向右进行计算
```
0*2+1=1
1*2+1=3
3*2+0=6
6*2+1=13
int res=0;
for(int i=0;i<arr.length;i++)
{
    res=res*2+arr[i];
}
```
上面就完成了10进制转化为其他进制,以及其他进制转化为2进制的问题
### 分析
然后我们来到这一道题,通过上面的问题,我们知道如果将一个等概率m得到等概率n的题,我们需要先将m扩大,变成一个大于或者等于n的值,然后在向会"筛选"
```
简单来说就是先扩在筛的过程
```
对于这一道题,我们要有一个大于等于N-1的值,然后通过这个进行筛选
```
我们可以将n-1变成m进制的数字,它有可能是k位,然后我们等概率的得到它的每一位,因为我们可以等概率的得到1------M,所以我们也可以等概率的得到0........M-1的数字,如果是大的我们就抛去
```
### 代码实现