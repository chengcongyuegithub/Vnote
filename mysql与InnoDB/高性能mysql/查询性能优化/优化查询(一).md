# 优化查询(一)
## 查询速度慢的原因
真正重要的是**响应时间**.查询看做是任务,由多个子任务组成,优化查询,要么优化子任务,要么减少子任务,要么减少子任务的执行次数,要么让子任务更快.
查询的生命周期,从客户端到服务器,然后在服务器进行解析,生成执行任务,执行,最后返回给客户端.

## 慢查询基础
对于慢查询两个步骤:
确认应用程序是否在检索大量需要的数据.
确认服务器是否在分析大量不需要的数据行.
### 请求了不需要的数据
多余的数据会被丢弃,给mysql服务器带来额外的负担,增加网络开销,消耗应用服务器的CPU和内存资源
* 查询了不需要的记录:mysql实际上先返回数据库在进行计算.使用limit
* 多个表关联时返回全部的列
* select *,额外的I/O,内存和cpu的消耗
有时候超过需要的数据,可以提高代码的重用性,
* 重复查询相同的数据 URL.
### mysql是否在扫描额外的记录
三个指标 响应时间,扫描的行数,返回的行数
响应时间:服务时间和排队时间.服务时间真正的时间,排队时间是等待阻塞,等待锁的时间

扫描的行数和返回的行数应该是相同的(理想情况下),如果做一个关联查询的时候,需要扫描多行才能返回一行,

扫描的行数和访问的类型
explain中的type列反应了访问的类型.访问的类型有多种
```
mysql> explain select * from sakila.film_actor where film_id=1;
+----+-------------+------------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
| id | select_type | table      | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra |
+----+-------------+------------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | film_actor | NULL       | ref  | idx_fk_film_id | idx_fk_film_id | 2       | const |   10 |   100.00 | NULL  |
+----+-------------+------------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```
因为有索引的存在,所以可以预估只查询10行.
```
mysql> alter table sakila.film_actor drop foreign key fk_film_actor_film;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> alter table sakila.film_actor drop key idx_fk_film_id;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from sakila.film_actor where film_id=1;
+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | film_actor | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 5462 |    10.00 | Using where |
+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```
当你删除索引,删除外键之后,就变成了全表扫描.
**where条件有三种:**
在索引中使用where条件来匹配过滤不必要的条件,存储引擎层完成的.
索引覆盖扫描,从索引中过滤不必要的条件,服务层完成.
从表中返回数据.然后过滤不满足的条件.服务层完成的.
```
mysql> select actor_id,count(*) from sakila.film_actor group by actor_id;
```
查询几千行,然后只返回200行,这种查询是无法使用索引的,所以这个使用要使用冗余表.
![](_v_images/20190508084626015_770353947.png =960x)
所以我们可以通过下面的方式来优化,这种情况(扫描的行数比较多,但是返回的行数比较少):

![](_v_images/20190508084716176_1980397880.png =960x)
