# 简单动态字符串
## 概述
SDS(简单动态字符串),是redis的默认字符串表示.
当我们执行命令
```
set msg 'hello world'
ok
```
键msg是一个字符串对象,对象的底层保存这一个'msg'的SDS
键对的值是也是字符串对象,保存这字符串"hello world"的SDS
```
rpush fruits "apple","banana","cherry"
(integer)3
```
键fruit是字符串对象,底层就实现了'fruits'的SDS
值是一个列表对象,包含了三个字符串对象,分别由三个SDS实现

## SDS和c语言的不同
sds可以表示为一个结构体
```
struct sdshar{
   //buf 已经存在的
   int len;
   int free 没有使用的数量
   char[] buf
}
```
free属性为0,表示SDS空间的字符串都被使用了,没有剩下的
len属性为5,5字节长字符串
buf就是char类型的数组.最后都会保留一个空字符,但是不算长度.
SDS是可以重用C语言字符串函数库中的函数
```
print("%s",s->buf)
```
### 获取字符的长度
C语言在获取字符串长度时,需要遍历,时间复杂度为O(N).
但是SDS记录字符的长度,所以时间复杂度为O(1).
### 缓冲区的溢出
C语言中有一个函数
```
char *strcat(char *dest,const char* src)
```
在执行这个函数时,如果分配的内存不够,就会缓存区溢出.
但是SDS就完全杜绝了这种情况,如果内存不够,会自己先拓展到执行修改所需要的大小
### 减少修改字符串时带来的内存重分配
在每次修改字符串的时候,在C语言中都要进行一次内存重分配的操作
拼接操作,需要拓展底层数组的空间大小----------否则缓冲区溢出
截断操作,需要重分配来回收不在使用的空间----否则内存泄露

在redis中,应用于速度要求苛刻,数据频繁修改.所以不可能每次字符串操作都会伴随这内存的分配.
SDS对于未使用的空间,实现了内存预分配和惰性空间释放两种优化策略.
**内存预分配**

在进行字符串拼接的时候,对SDS进行空间拓展,分配所需要的空间,还会分配额外的未使用的空间
具体操作如下:
**如果对SDS进行修改之后,SDS的长度将小于1mb,那么程序分配和len属性同样大小的未使用空间.
如果修改之后len的长度变成了13字节,那么程序也会分配13字节的未使用空间,buf的长度就会变成
13+13+1=27字节(不包括空字符)**
**如果对SDS进行修改之后,SDS的长度将大于等于1mb,那么程序就会分配1mb的未使用空间,举个例子
如果进行修改的话,SDS的len将变成30MB,那么程序会分配1mb的未使用空间,SDS的buf数组的实际长度为30Mb+1Mb+1byte**

**惰性空间释放**
惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时,程序并不立即
使用内存重分配来回收缩多出来的字节,而是用free属性将这些字节记录起来,等待将来使用.

### 二进制安全
C语言只能保存文本数据,因为空字符.
redis可以用来保存二进制数据,SDS的API都是二进制安全的

### 兼容C语言的库函数