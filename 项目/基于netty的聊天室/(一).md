# (一)
## 1,单聊
### 1.1,单聊的流程
![](_v_images/20190605221633326_1418370945.png =660x)
1,如上图，A 要和 B 聊天，首先 A 和 B 需要与服务器建立连接，然后进行一次登录流程，服务端保存用户标识和 TCP 连接的映射关系
2,A 发消息给 B，首先需要将带有 B 标识的消息数据包发送到服务器，然后服务器从消息数据包中拿到 B 的标识，找到对应的 B 的连接，将消息发送给 B
3,任意一方发消息给对方，如果对方不在线，需要将消息缓存，对方上线之后再发送
`A和B连接首先要和服务器建立连接,然后服务器保存两个标识`
`当A----->B的时候,因为服务器都有不同连接带有的标识,发给B那就是B的标识发给服务器,然后在服务器中找到B的标识,然后发送数据`
`如果对方不在线,那么就要消息缓存,等对方上线之后再发送`
我们把客户端与服务端之间相互通信的数据包称为`指令数据包`，`指令数据包分为指令和数据`，每一种指令对应客户端或者服务端的一种操作，数据部分对应的是指令处理需要的数据。
```
指令表示数据包的操作,而数据表示需要处理的数据,也就是传送的内容
```
### 1.2,单聊的指令
![](_v_images/20190605222122910_662642228.png =660x)
| 指令内容     | 客户端     |  服务端   | 
| --- | --- | --- | --- | --- |
| 登录请求     |  发送    |   接收  |  
|  登录响应   |  接收   | 发送    |     
| 客户端发消息    |   发送  | 接收    |   
|  服务端发消息   |   接收  |  发送   |  
|   登出请求  |  发送   | 接收    |  
|   登出响应  |  接收   | 发送    |    
## 2,群聊
### 2.1,群聊的流程
群聊指的是一个组内多个用户之间的聊天，一个用户发到群组的消息会被组内任何一个成员接收，下面我们来看一下群聊的基本流程
![](_v_images/20190605222530204_2053066877.png =660x)
1,A，B，C 依然会经历登录流程，服务端保存用户标识对应的 TCP 连接`群聊的成员都要和服务器建立连接`
2,A 发起群聊的时候，将 A，B，C 的标识发送至服务端，服务端拿到之后建立一个群聊 ID，然后把这个 ID 与 A，B，C 的标识绑定`群聊的ID就相当于这个聊天室的标识,其中value就是List,存着的都是成员`
3,群聊里面任意一方在群里聊天的时候，将群聊 ID 发送至服务端，服务端拿到群聊 ID 之后，取出对应的用户标识，遍历用户标识对应的 TCP 连接，就可以将消息发送至每一个群聊成员`服务器拿到数据之后,遍历所有用户的TCP连接`
### 2.2,群聊的指令集
![](_v_images/20190605222817404_1993620811.png =660x)
| 指令内容     | 客户端     |  服务端   | 
| --- | --- | --- | --- | --- |
| 创建群聊请求     |  发送    |   接收  |  
|  群聊创建成功通知   |  接收   | 发送    |     
| 加入群聊请求    |   发送  | 接收    |   
|  群聊加入通知       |   接收  |  发送   |  
|   发送群聊消息  |  发送   | 接收    |  
|   接收群聊消息  |  接收   | 发送    |    
|   退出群聊请求  |  发送   | 接收    |  
|   退出群聊通知|  接收   | 发送    |    

## 3.netty在客户机的体现
![](_v_images/20190605223216161_1034012339.png =660x)

1,首先，客户端会解析控制台指令，比如发送消息或者建立群聊等指令
2,然后，客户端会基于控制台的输入创建一个指令对象，用户告诉服务端具体要干什么事情
3,TCP 通信需要的数据格式为二进制，因此，接下来通过自定义二进制协议将指令对象封装成二进制，这一步称为协议的编码
4,对于收到服务端的数据，首先需要截取出一段完整的二进制数据包（拆包粘包相关的内容后续小节会讲解）
5,将此二进制数据包解析成指令对象，比如收到消息
6,将指令对象送到对应的逻辑处理器来处理

## 4.netty在服务器的体现
![](_v_images/20190605223234401_1250135271.png =660x)
